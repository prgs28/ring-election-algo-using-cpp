#include <Windows.h>
#include <stdio.h>
#include<thread>
#include<iostream>
#include<conio.h>
#include<stdlib.h>

using namespace std;

int n,leader,process[8];	//no. of processes in the ring
int status[8];				//status of every process; if it is 1 then process is alive ; if 0 then dead
int message[8];				//this is a token array; the process having message will have its message[i]=1 else 0
int myid;					//used by election function

void init(int i)			//to initialize values at the begining; so that it won't store garbage value
{
	::status[i]=1;
	::message[i]=0;
	//cout<<"\n"<<::process[i];
}

void init_ele(int myid)				//function to initiate election
{
	int i;
	if (myid == n - 1)				
		i = 0;
	else
		i = myid + 1;
	int lead = myid;			//look is local varialbe for this function to elect the coordinator
	int look = 0;
	while (look == 0)
	{
		if (::status[i] == 1)
		{
			if (::process[i] > lead)
			{
				cout << "\nprocess " << i << " and previous coordinator " << lead << " elected ";
				lead = ::process[i];
				if (i == n - 1)
					i = 0;
				else
					i++;
				cout << lead;
			}
			else if (::process[i] < lead)
			{
				cout << "\nprocess " << i << " and previous coordinator " << lead << " elected ";
				if (i == n - 1)
					i = 0;
				else
					i++;
				cout << lead;
			}
			else
			{
				cout << "\nELECTION GENERATED BY " << myid;
				cout << "\nNEW COORDINATOR IS " << lead<<"\n";
				look = 1;
				Sleep(2000);
			}
			Sleep(2000);
		}
		else
		{
			if (i == n - 1)
				i = 0;
			else
				i++;
		}
	}
	::leader = lead;			//leader gets the value of new leader from lead
}


void messagepass()				//function that sends the token to all processes
{
	int count=0;
	for(int i=0;i<::n;i++)
	{
		if(::status[i]==0)		//process dead
		{
			cout << "\nPROCESS " << i << " IS DEAD";
			Sleep(2000);
			cout << "\nfor basic algorithm: \nPROCESS " << i - 1 << " INITIATES ELECTION";
			init_ele(i-1);
			Sleep(2000);
			cout<<"\nas asked in the assignment:\nPROCESS 2 & PROCESS 5 INITIATES ELECTION";
			Sleep(2000);
			std::thread t1(init_ele, 2);	//thread 1 initiates election
			std::thread t2(init_ele, 5);	//thread 2 initiates election
			t1.join();
			t2.join();
			break;
				
		}
		else
		{
			if (count <= ((::n) - 1))
			{
				count++;
				for (int j = 0; j < ::n; j++)
				{
					::message[j] = 0;			//all messages all 0 i.e. no one has the token
				}
				::message[i] = 1;				//message given to the current process	
				Sleep(3000);
				cout << "\nmessage is with process: " << i;
				
				if (count == ::n )
					cout << "\nALL PROCESSES ARE ACTIVE AND HAVE RECIEVED MESSAGE";

			}
		}
	}
	Sleep(2000);
}

void kill(int pro)			//to kill the process
{
	::status[pro]=0;
	messagepass();	
}

void reactivate(int pro)			//to activate the dead process
{
	::status[pro] = 1;
	cout << "\nPROCESS " << pro << " IS BACK TO LIFE!!";
	init_ele(process[pro]);
	messagepass();
}



int main()
{
	int i;
	int x;
	cout << "\n\t\t****PRAGYA TRIVEDI****\n\t\tUID:1001518488";
	cout<<"\nenter no. of processes:";
	cin>>::n;
	cout<<"\nenter sequence of the process:";
	for(i=0;i<::n;i++)
	{cin>>::process[i];}
	for(i=0;i<::n;i++)
	{
		init(i);
		Sleep( 1000 );				//a 5 seconds Sleep after activation of every process
		
	}
	::leader=process[::n-1];
	cout<<"\nall processes created";
	Sleep(3000);
	system("cls");
	messagepass();		//to check whether all processes are alive & recieving messages or not
	cout << "\nenter which process to kill(other than 2&5)...";
	cin >> x;
	kill(x);
	reactivate(x);
	return 0;
	
}

